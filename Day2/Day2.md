上午 
========
我唯一能够说的就是那个讲义实在是太少了……

强烈怀疑少印了页数……以及下一次应该早点去抢座位的

这么说吧，由于某完全不知道Linear Programming到底是什么的东西因此整堂课就像在梦游一样……
（于是乎只能够写点奇怪的东西在上面了，权当是在网络流问题中的一种处理思路吧。）
***
线性规划本身，并非作为一种处理问题的思路，而是作为一种处理问题的思想来完成的。
也就是说，单纯的线性规划四个词语，可能只需要简单的处理来完成，也有可能是属于NP完全问题的范畴。

网络流问题，实际上可以被认为是线性规划的系列问题中间一个比较容易被解决的分支（有多项式时间的解法）

可以说，所有的网络流问题都可以根据流量平衡方程的原则，得到一个线性规划的多项式关系式。
这样的关系式的特点在于所有的系数都属于{-1,0,1}（流量平衡，分别代表出度、入度和不存在边）

_显然，线性规划的模型本身的建立比网络流模型要简单很多。_（虽然某完全看不出来这一点）

然后嘛，对于这样子的线性规划模型的约束，只要经过一定的变换可以得到那样的方程组/不等式的话，那么这样的问题都可以使用一定的网络流算法来进行解决。

（于是乎主要是后面一些小题目体现的思想和方法吧？）

拆点实现点权这样的东西我想这是大家都知道的技巧吧

关于在最大费用最大流之间的算法，如果使用所有取相反数来转换为
实际上有一些技巧来可以实现负权环的去除……

具体方法：
```首先，消圈与源汇没有任何关系，所以我们可以无视源汇。

然后我们把每个点i拆成两个点i和i'，并添加超级源汇S和T。

从S向每个点i连一条容量为M，费用为0的边。
从每个点i到i'连一条同样的边。
每个点i'到T亦然。
// M=+∞，为了方便说话用M代替，实际应该使用比流量总和还要大的数

然后对于原图中每一条边(i,j,flow,cost)，在新图中建边(i,j',flow,cost)

在新图中运行最小费用最大流算法，对于每条边(i,j')上的流量都直接从原图中强制流掉并删去。
可以保证残量网络没有负圈。
而只要起初残量网络中没有负圈，以后也不会有。

可以使用SPFA找增广路了！：）

这个方法是正确的。

为什么呢？

证明略```
by赵亮 ，某太弱了::>_<::

所谓有上下界限制的网络流，如果要求求出解的方案的话，那么就是先按照下界做一遍网络流（要加上伪源汇点的处理），接下来对残量网络进行一遍普通的最大流

以及还有所谓的广义的匹配问题……（N分图匹配？）这个应该不需要阐述了喵
下午
========
下午福利：http://video.sina.com.cn/v/b/92730979-1892506990.html （貌似）
B站的post被删了

下午的东西感觉大家都不是很感兴趣的样子？
（其实也就是所谓的毛用东西）

大意就是阐述一下[IEEE 754/854][1]里面规定的计算机的实数表示方法。

以及唯一感到比较奇怪的东西（实验性？）的东东大概就是所谓的误差的复杂度计算。

这么说吧，所谓的误差可以被考量为对于在有效位数之下的随机偏差，
然后对于这样产生的无法计算偏差，要对其进行一定程度上等概率的修正来使其满足最终的数学期望仍然符合精度。

然后所谓的误差复杂度计算，其实实际上就是对于函数[偏导数][2]的计算的数量级考查。

打个比方，tanθ的导函数是1/cos^2θ，那么偏导数就是1/cos^2θtanθ。
该偏导数按照θ的增长呈现非多项式级别的增长，因此是一个病态函数。在这种函数的误差将会以非常快的速度累加。

还有就是经常用到的一个东西，对于eps来说，有的时候平方等操作可以使得你的数发生巨大改变，然而它的绝对误差虽然极大变化（O(N)级别 ），但是相对误差却基本没有变化（O(1)级别）
这样的话在这样的处理过程中，相对的eps（例如一千万分之一N）可以比普通的eps更加有效。

晚上福利
========
很抱歉某太无能没能够把丽洁姐的pdf拷下来
0 0大家就这么看看吧（念写记者胡诌中……）
Python简介
--------
@翁健

※你们什么也没有损失

多项式乘法
--------
无法理解的内容……
我除了记下所有的名词我什么也干不了了

多项式
伯努利数
二项式反演
卷积
FFT
中国剩余定理
SDN
积性函数
线性筛
逆元

每一个化简过程三页半分钟讲完我就不说什么了……

唯二有用的东西听不懂了QAQ……

（此坑以后再填）

一些其他的后缀数据结构……？
--------
于是看到这个标题大家应该都明白发生了什么可怕的事情了……
（切换到念写姿态）

等等，这是什么……？
--------
首先，我想我也许不需要重复一些东西的概念（嘛~）

后缀自动机，作为一个有限状态自动机，他的原理显然大家都明白的~

所谓的后缀自动机的工作原理，实际上完全是基于这样的理念，即记录自动机的操作过程实质上是通过记录状态的转移方式。
那么，如果能够将这样的转移的方法进行记忆化处理，则可以在一定程度上实现记录你的历史状态。

实际上，所谓的可持久化，对于后缀自动机是一个“伪命题”。显然，后缀自动机根本没有删除操作。（因为删除尾节点可能会造成无法估量的影响）

（不过实际上clj似乎对于删除节点在WC的时候提出了一种新的思路，表示某还没有认真听到继续毛想想……）

（一定程度上），我们可以认为后缀自动机插入的时间是平摊O(N)的。那么，恢复到某一个历史状态的操作（回滚操作）显然从一定程度上也是可以实现的。

这样就有了一个奇怪的可持久化实现。对于这样的可持久化实现，不是基于链的存储，因为后缀自动机根本没有删除节点这个操作。

于是乎嘛……？

然后呢？
---------
这样的可持久化实现，是基于回滚（Roll Back）的操作，而非是真实的操作来实现的。这样的操作从某种意义上并不是传统的基于链的可持久化实现，而是基于树结构了。
（大家可以类比一下svn和git的区别和对比）

然后于是乎我们发现，我们的确架构出来了一个可以支持任意回滚和单插入的数据结构，然而这样的数据结构显然无法用于解决许多的问题……

对于回滚的操作，我们必须要对于每一个节点进行还原现场的操作（这样的时间复杂度将会是无法忍受的O(N)，并且几乎无法用任何的手段来优化（因为时间戳标记将不再有效））

（在这样子的模型之下，由于修改是树形的结构，所以说目前还不能找到什么线性的维护的方法来完成这样的事情。并且，由于对于回滚树没有Merge这样的操作（0 0有了就不是树了），整个版本的管理将会是发散的）
（因此，为了高效地实现这样的东西，对于记录在不同的时间戳之下子树的管理可能需要奇怪的方法来进行维护。）

于是乎从某种意义上来讲，这种实验性的思想还很难通过某种切实存在的方法来加以完成（所以说就是个坑吧啊喂！）

就这样？！
---------
这么说吧，实际上，虽然我们目前为止还只是挖了一个巨大的坑，但是还是无法阻止我们找到一种新的思路。

对于字符串后面加的字符，有的时候转化成对倒置串前面加的字符。然后将查询串也导致之后，产生的结果是不变的，然而在后缀数组中，你只需要新建一个全新的后缀就可以了。
而对于看上去无解的删除操作，实际上也可以通过相同的处理来解决。

（后缀自动机这么玩？乃在开玩笑吧）

这么说吧，于是乎，对于这样一个简单的添加/删除操作，我们可以在很小的代价之内进行改变的操作。从某种意义上，后缀数组的可持久化是很容易实现且可以取得较好效率的。

可是……这……
---------
还没有想明白么？不过，也许还有一个比较好玩的东西。

参照KMP算法，可以在树的链上面运作来获得一个更加复杂的数据结构（AC自动机）。那么，由于后缀自动机的结构是完全和N级别相关的（简单性），同时也有相对较良好的树组织性（有效性），也就是说……

对于一个Trie，如果我们把它整体进行一次这样的处理，那么就可以求得一个全新的数据结构，可以做到对多个串的模式匹配问题。

//以上内容全部由不负责任的念写完成。全部和主题无关

[1]: http://zh.wikipedia.org/wiki/IEEE_754
[2]: http://zh.wikipedia.org/wiki/%E5%81%8F%E5%AF%BC%E6%95%B0

