于是乎在这里码点字因为赵亮要看
（不过说起来就算赵亮来了某也会写的……？）
上午 
========
就是吐槽吐槽NOI的题目太长组织出问题，吐槽韩国队，以及什么其他奇奇怪怪的东西，大概的意思嘛就是这样。

（其实真正的本体是CEOI2012的题解吧） 

（并且实际上没有讲完……？） 

 这么说吧其实某也没有听完（或者说被一开始的迷糊了……）
 
下午 
========
先是讲了点计算几何基础 ……（上午好多人在吧里面问什么是极角啊囧……）

于是乎大家都明白吧（不明白的话自己去看本子啊喂……）

平面图的基本性质
--------
平面图是一个边和边之间不在点以外位置相交的可平铺的简单图

于是乎首先下一个定义，在平面图之中由边划分开来的连通区域被称为域（face，在某本本子上用字母r表示）
点数是n，边数是m，联通块数（边的联通块）是k

这么说吧，根据[欧拉公式][1]可以很容易推导出r=m-n+k+1，于是乎由于2m>=3r（每个域至少要有三条边围成）
于是乎可以推出的是r和m与n都是呈现一次关系（也就是说对于一个图，rmk都是n量级的）

存储结构……（还有别的吗？）
--------
这么说吧，首先为了方便画图，我们对于一个图在外面画一个大圆圈来表示那个无穷大的域

参照一下图的存储方式（点 下挂 链表存储所有出度边）

于是乎，我们可以想到以下的存储
1. 对于一个域，我们要存储所有在它的边界上的边和点，这样就可以快速遍历所有与之有关的东西。
2. 对于一个域，我们要存储所有它相邻的域。

第一个东西嘛，显然是所有问题处理的关键，于是乎……

卷卷卷卷包袱？
--------
这样的构造过程，似乎是不能找到一个O(N)的算法来构造的）

然而我们可以找到一个迷糊的方法来完成这样的一个过程。这个过程来自与一个简单的思路：

1. 将所有的边全部当作有向边（？）
2. 把每个点发出的边全都按照顺时针排序（？？）
3. 任取一条没有访问过的边，然后不断选择最左侧未走过的边，直到返回出发的边。

看上去有点像卷包袱的做法（实际上真的很像！），在这样子绕了一圈之后，就一定会找到一个域（包括一开始的无穷域喵~）

然后呢……？
--------
第二个东西看上去有那么一点多余，然而他有一个奇怪的用处。这样的相邻的域所组成的列表被称为对偶图，也就是说……

对于对偶图，我们可以把每条原图中的边逆时针旋转90°，这样之后就会形成一张新图，我们可以非常简单的看到，这张图的最短路就是很多时候想要的……

……最小割？也就是最大流？

不过等等，如果是这样的话，那么为何要存储第一个部分呢？

然后呢——？
--------
于是乎当当当当，我们会想到一个奇怪的东西，显然我们如果要往这个奇怪的平面图里面撒一个点的话，我们需要干一些奇怪的事情。

首先，我们先假定这张图每个点都没有重复的横坐标

于是乎喵，我们可以垂直于点画很多竖线来把他们分割成许多个小部分。在每个部分的二分查找的时间复杂度是可以接受的（logn）

（然而除非你能够接受这样的预处理时间复杂度：n^2 logn）

糊你熊脸！

你说这孩子挺会玩的！这不比暴力还慢吗？

（其实我会告诉你竖直方向的竖线最多只要经过刚好在这个点上面和下面的两条横线就够了吗？）

于是乎你就画出了这张图，上面是许多个梯形，看上去完全没有用处。因为它不能被二分查找？

（这么说吧，我们先做一个小实验，你被设计回答一系列（这个点在某条线的上面吗？/这个点在某条线的左侧吗？）之类的问题，是否一定能够在有限次数内得到这个点所在的域？）

于是乎这样的问题，显然可以形成一个二叉树结构。大家都很开心。除了让你想到了不自平衡的二叉树而已。

因幡的白兔
--------
这么说吧，我们首先知道，对于这样的问答结构，显然有许多不唯一的方式来形成。

对于任何一个域，最多只需要回答四个底层问题便可唯一确定，于是乎对于我们所有域的问题的求和的平均数嘛，就是一个大家都喜闻乐见的级数Σ(4/(n-i))i=1→n
（证明？不要问我啦）

很显然这样子可以最终弄成一个大家都喜欢的无穷级数e，于是乎这样的问题最终可以被转化到平均lnN的级别

问题是我们大家都知道有个叫退化的问题，所以……

（*你写过Treap吗？*）

纸上的粉笔灰
--------
然而这个东西就比Treap要麻烦一点了。首先，随机插入的新边有可能会横跨多个区域。在这些区域中间，大部分时候你会穿过一条邻居的视野线

（遮挡→合并？）

这样的话显然为了保存这样图的性质，显然，最终添加的矩形数目的增量最终是常数的~

还有一件小事情呢，也就是说，为了处理重复的点的问题，我们要做一件小事情。

既然这是一张平面图，那么显然，将其旋转一个极小的角度是可以保证使得所有的东西都不拥有同样的横坐标的~

不过嘛，实际上大部分时候我们不需要真的去旋转。因为这是一个矢量的图形，把它放大并旋转使得构成了一个(x,y)→(x+ax,y)的变换（并变换比例尺）结果和原图显然是等价的~
（a远小于x,y）

然后嘛，实际上，我们在比较时根本不需要真的a，只需要在判断左右的时候以x为第一关键字（因为a远小于x,y），y为第二关键字就可以了~

（上下？这样的变化不会影响上下关系~你可以试着进行与原点连线~）

晚上·河童的娱乐和猫
========
最喜欢的东西了~各种理性愉悦~

所谓各种成熟的不成熟的新技术老技术的交汇的所在~如同河童的市场一样

线段树的合并操作 by 主席
--------
主席终于不讲主席树了（然而所有的内容全都会说这可以用主席树做……）

简单的说吧，线段树的合并操作进行的时候，两颗线段树大部分时候并非完全是满的（甚至全都是空的）

然后就是一种常见的处理方法（自顶向下按需建构的线段树嘛，很有可持久化的感觉）

其实呢，对于把线段树倒过来的过程，也是完全可行的。也就是说，通过线段树的合并，我们可以在O(N)的时间内进行区间最优的树形DP过程~

（反正有ppt的）

2D物理引擎浅析 by hym
--------
（啊咧以前我也看过[Box2D][2]源代码来着）

这么说吧，就是在这样的过程中遇到的各种问题的各种解决了喵。

物理模拟是一个十分麻烦的过程。显然越简单的模型体系（原子化模拟）就意味着越低的效率。对刚体行为的封装在提高了效率的过程中也出现了问题

所谓的子弹问题应该是刚体在赋予冲量之后在一个Tick之内直接由于动量过大而在判定中被认为从另一个方向发生刚体碰撞吧……（咦好像扯远了）

GPGPU和并行计算 by cyf&&gjq
--------
《论Demo的自我修养》

这么说吧，虽然在NOIP比赛之中不可以使用多线程，但是在开发过程中和一些提交答案题目里面还是十分常用的。

以及GPU在并行计算方面还是挺不错的……A卡算BTC比CPU平均能快20倍来着……

（不过zhq这回真是颜面何存……不提了不提了）

二项堆和斐波那契堆 （那家伙和lyd比起来简直阿卡林了……）
--------
[二项堆][3]是一个奇怪的数据结构。

和同样可并的堆数据结构左偏树不一样。二项堆似乎是严格logN，并且它不是一个单一的堆，而是一个森林。

简单的说，二项堆中维护多个不同高度的堆结构。对于合并之时按照高度从小到大的顺序，
如果该高度有需要合并的节点，那么因为两个高度相同，所以将其中一个的堆顶元素作为堆顶元素，剩下来的和另一颗树作为子树就可以形成高度为其高度+1的堆。循环往复
这样的话每种高度最多只有一个子树，子树的总个数也是logN的

那么斐波那契堆也是基于这样的原理。只不过呢，斐波那契堆基于平摊分析，并且让较少的操作分担了几乎所有的工作量（极高的常数）

斐波那契堆的结构更加松散。整个是一个大的森林，头指针指向最小的儿子，而其他的兄弟之间由双链表连接。每个堆的内部也由这样维护。

* 插入这样的操作，Fib堆直接在将其插入森林的链表之中。
* Pop操作则要麻烦一些。要将所有的子树放进1~logN的桶中，然后像二项堆一样合并
* DecreaseKey则如果会影响堆序，那么则将其打上删除标记后重新插入根表。如果其父辈没有被删除，则删除它们。 

[1]: http://zh.wikipedia.org/wiki/%E5%B9%B3%E9%9D%A2%E5%9B%BE_(%E5%9B%BE%E8%AE%BA)#.E6.AD.90.E6.8B.89.E5.85.AC.E5.BC.8F
[2]: http://www.oschina.net/p/box2d
[3]: http://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A1%B9%E5%A0%86

